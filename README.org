#+FILETAGS: cachew

* Cachew: quick cache for your NamedTuples
It works, or, strictly speaking, [[https://docs.python.org/3/library/typing.html#typing.Iterator][Iterator]]

#+BEGIN_SRC python
>>> from typing import Collection, NamedTuple
>>> from timeit import Timer
>>> class Person(NamedTuple):
...     name: str
...     age: int
>>> @cachew
... def person_provider() -> Iterator[Person]:
...     for i in range(5):
...         import time; time.sleep(1) # simulate slow IO
...         yield Person(name=str(i), age=20 + i)
>>> list(person_provider()) # that should take about 5 seconds on first run
[Person(name='0', age=20), Person(name='1', age=21), Person(name='2', age=22), Person(name='3', age=23), Person(name='4', age=24)]
>>> res = Timer(lambda: list(person_provider())).timeit(number=1) # second run is cached, so should take less time
>>> assert res < 0.1
>>> print(f"took {res} seconds to query cached items")
took ... seconds to query cached items
#+END_SRC

** TODO [2019-07-30 Tue 18:58] how to insert doctest here?

* why Sqlite?
  effecien, easy to interface with other tools

* why NamedTuple?
    
* why not pandas.DataFrame
  DataFrames are great and can be serialised to csv or pickled. They are good to have as one of the ways you can interface your data,
and can't be statically analysed because of dynamic TODO

  
* why not ORM (e.g. sqlalchemy ORM TODO link)
see why NamedTuple


** TODO [2019-07-30 Tue 19:00] post some link to data classes?
